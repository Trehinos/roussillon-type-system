@startuml
interface kind {
    todo
}
class effect {
    todo
}
kind <-- effect
interface type
interface never {
    __
    enum {}
}
interface any {
    todo
    __
    dyn(?)
}
kind <- type
never --> type
any --> type
interface primitive
interface datatype
type <- datatype
datatype <-- primitive
class bool
primitive <--- bool
interface number {
    __
    trait Number
}
class byte {
    8 bits
}
number <--  byte
class bytes(byte)
number <-- "bytes(byte)"
class arch
"bytes(byte)" <-- arch
class word {
    2 bytes
    16 bits
    __
    UTF-16 char
}
"bytes(byte)" <-- word
class quad {
    4 bytes
    32 bits
    __
    UTF-32 char
}
"bytes(byte)" <-- quad
class long {
    8 bytes
    64 bits
}
"bytes(byte)" <-- long
class wide {
    16 bytes
    128 bits
    __
    UUID
}
"bytes(byte)" <-- wide
primitive <-- number
class int {
    8 bytes
    64 bits
    __
    Signed
}
number <--  int
class float {
    8 bytes
    64 bits
    __
    IEEE 754 binary64
}
number <--  float
class &type {
    __
    Reference
}
primitive <-- "&type"
class " [type, arch]" {
    __
    Array
}
primitive <-- " [type, arch]"
class "&[type, arch]" {
    __
    Slice
}
primitive <-- "&[type, arch]"
"box(type)" --> datatype
"dyn(type)" --> datatype
class tuple
class unit {
    __
    ()
}
datatype <-- tuple
tuple <-- unit
interface adt
interface gadt {
    todo
}
class trait {
    todo
    __
    Implementation of an interface for a record
}
class model {
    todo
    __
    Implementation of a record
}
class enum
class record

datatype <-- adt
adt <-- sum
adt <-- product
product <-- record
sum <-- enum

type <-- gadt
interface interface {
    todo
}
type <-- interface
interface <-- trait
interface <-- model
trait o- model
class "type -> type" {
    wip
}
type <-- "type -> type"
class box(type) {
    wip
}
class dyn(type) {
    wip
}

@enduml