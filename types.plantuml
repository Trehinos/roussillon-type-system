@startuml
interface Any {
    --
    type_id: &Self -> arch
    size_of: &Self -> arch
}
interface Copy {
    --
    copy: &Self -> Self
}
interface Displayable {
    --
    to_string: &Self -> String
}

Any <.. Primitive
Copy <.. Primitive
Displayable <.. Primitive
abstract Primitive

interface Boolean {
    --
    and (&) : (&bool, &bool) -> bool
    or (|) : (&bool, &bool) -> bool
    xor (^) : (&bool, &bool) -> bool
    eqv (|<>|): (&bool, &bool) -> bool
    not (!): &bool -> bool
    nand (!&) : (&bool, &bool) -> bool
    nor (!|) : (&bool, &bool) -> bool
    imp  (|>) : (&bool, &bool) -> bool
    nimp (|!>) : (&bool, &bool) -> bool
    rimp (<|) : (&bool, &bool) -> bool
    rnimp (<!|) : (&bool, &bool) -> bool
    ternary<L,R> (?,:) : (&bool, L, R) -> L:R
}
Primitive <--- bool
Boolean <-- bool
class bool

interface Bitwise {
    --
    and (&) : (&Self, &Self) -> Self
    or (|) : (&Self, &Self) -> Self
    xor (^) : (&Self, &Self) -> Self
    eqv (|<>|) : (&Self, &Self) -> Self
    nand (!&) : (&Self, &Self) -> Self
    nor (!|) : (&Self, &Self) -> Self
    imp (|>) : (&Self, &Self) -> Self
    nimp (|!>) : (&Self, &Self) -> Self
    rimp (<|) : (&Self, &Self) -> Self
    rnimp (<!|) : (&Self, &Self) -> Self
}
interface Equal {
    --
    eq (==) : (&Self, &Self) -> bool
    ne (!=) : (&Self, &Self) -> bool
}
interface Compare {
    --
    gt (>) : (&Self, &Self) -> bool
    ge (>=) : (&Self, &Self) -> bool
    ge (<=) : (&Self, &Self) -> bool
    lt (<) : (&Self, &Self) -> bool
    min : (&Self, &Self) -> Sel,
    max : (&Self, &Self) -> Self
}
interface SignedArithmetic {
    --
    add (+) : (&Self, &Self) -> (Self, Self)
    sub (-) : (&Self, &Self) -> (Self, Self)
    mul (*) : (&Self, &Self) -> (Self, Self)
    div (/) : (&Self, &Self) -> (Self, Self)
    mod (%) : (&Self, &Self) -> (Self, Self)
}
Primitive <-- Native
Bitwise <.. Native
Equal <.. Native
Compare <.. Native
SignedArithmetic <.. Native
interface Bitset {
    bit : (&word, byte) -> bool
    set : (&mut word, byte, bool) -> ()
}
Bitset <.. Native
abstract Native
Native <-- byte
class byte

interface Byteset {
    merge : (&Self, &bytes< u >) -> bytes< s + u >
    split : (&bytes< s + u >, arch) -> (bytes< s >, bytes< u >)
    to_bytes : (&self) -> &[byte]
}
Byteset <.. bytes
Native <-- bytes
class bytes< s: arch >

bytes <-- word
class word {
    s = 2
}
bytes <-- quad
class quad {
    s = 4
}
bytes <-- long
class long {
    s = 8
}
bytes <-- wide
class wide {
    s = 16
}

Native <-- arch
class arch

interface Arithmetic {
    --
    add (+) : (&Self, &Self) -> Self
    sub (-) : (&Self, &Self) -> Self
    mul (*) : (&Self, &Self) -> Self
    div (/) : (&Self, &Self) -> Self
    mod (%) : (&Self, &Self) -> Self
}

Compare <.. Number
Primitive <----- Number
Arithmetic <.. Number
abstract Number

Equal <.. int
Number <-- int
class int

Number <-- float
class float

interface Borrowable {
    --
    deref (*$) : (Self) -> T
    borrow : (&Self) -> &T
    borrow_mut<T> : (&mut T) -> &mut T
}
Primitive <--- "&T"
Borrowable <-- "&T"

class "&T" {
    mutable: bool
}

interface Collection< T > {
    --
    item ($[$]) : (&Self, arch) -> &T,
    item_mut (mut $[$]) : (&mut Self, arch) -> &mut T,
    length : &Self -> arch,
}
interface Iterator< T > {
    --
    iterate : &mut Self -> ?&T
    iterate_mut : &mut Self -> ?&mut T
    reset : &mut Self -> ()
}
interface Enumerator< T > {
    --
    enumerate: &mut Self -> ?(&K, &T)
    enumerate_mut: &mut Self -> ?(&K, &mut T)
    reset: &mut Self -> ()
}

Primitive <--- "[T; s]"
Collection <.. "[T; s]"
Iterator <.. "[T; s]"
Enumerator <.. "[T; s]"
class "[[T; s]]" {
    --
    get_slice: &Self -> &[T]
}

Any <.. Composite
Copy <.. Composite
abstract Composite

Composite <-- Tuple
class Tuple {
    types: &[any]
}
Composite <-- "T & S"
class "T & S"<T, S>
"T & S" -o Tuple
"T & S" <-- struct

Composite <-- "T | S"
class "T | S"< T, S >
Tuple o- "T | S"
"T | S" <-- enum
@enduml